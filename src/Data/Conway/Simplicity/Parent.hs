{-# LANGUAGE ViewPatterns #-}

-- | Let @S + veb o p c@ be a @Conway@ with a trailing term.
--
-- Let @'@ be the left parent of a surreal number, and @''@ be the right parent.
--
-- The range can be empty (zero), singleton (successor) or range (limit).
--
-- @n = 0, 1, 2, ...@ is the index of a limit range.
--
-- * SumL and SumR: @(S + veb o p c)' = S + (veb1 o p c)'@ and also for @''@
--
-- ** Monominal rules
--
-- * CoeffLSucc: @(mono p c)' = mono p c' + mono p' n@
--
-- * CoeffRSucc: @(mono p c)'' = mono p c'' - mono p' n@
--
-- * CoeffLLimit: @(mono p c)' = {0, mono p' c}@
--
-- * CoeffRLimit: @(mono p c)'' = mono p''@
--
-- ** Mono1 rules
--
-- * Mono1LSucc: @(mono1 p)' = {0, veb 0 p' n}@
--
-- * Mono1RSucc: @(mono1 p)'' = veb 0 p'' (1 `shr` n)@
--
-- * Mono1LLimit: @(mono1 p)' = {0, mono1 p'}@
--
-- * Mono1RLimit: @(mono1 p)'' = mono1 p''@
--
-- ** Veb1 rules
--
-- The @Veb1@ rules are based on the "CGV Googology part 1: veblen function" definition of the surreal single-argument Veblen function:
--
-- @veb1 o p = { 0, p' * n, iterate (veb1 o') {0, p' * n} | p'' * (1 `shr` n), iterate (veb1 o') (p'' * (1 `shr` n)) }@
--
-- where @n@ is the range @{0, 1, 2, 3, 4, ...}@ and @1 `shr` n@ is the range @{1, 1/2, 1/4, 1/8, 1/16, ...}@
--
-- * Veb1LLimitZero: @(veb1 o 0)' = veb1 o' 0@
--
-- * Veb1RLimitZero: @(veb1 o 0)'' = {}@
--
-- * Veb1LSuccZero: @(veb1 o 0)' = iterate (veb1 o') 0@
--
-- * Veb1RSuccZero: @(veb1 o 0)'' = {}@
--
-- * Veb1LSuccSucc: @(veb1 o p)' = iterate (veb1 o') (veb1 o p' + 1)@
--
-- * Veb1RSuccSucc: @(veb1 o p)'' = iterate (veb1 o') (veb1 o p'' - 1)@
--
-- * Veb1LSuccLimit: @(veb1 o p)' = veb1 o p'@
--
-- * Veb1RSuccLimit: @(veb1 o p)'' = veb1 o p''@
--
-- * Veb1LLimitSucc: @(veb1 o p)' = veb1 o' (veb1 o p' + 1)@
--
-- * Veb1RLimitSucc: @(veb1 o p)'' = veb1 o' (veb1 o p'' - 1)@
--
-- * Veb1LLimitLimit: @(veb1 o p)' = veb1 o p'@
--
-- * Veb1RLimitLimit: @(veb1 o p)'' = veb1 o p''@
module Data.Conway.Simplicity.Parent
  ( ParentSeq,
    ConwaySeq (..),
    MonoSeq (..),
    Veb1Seq (..),
    LeftRight,
    lrConway,
    parentDyadic,
    parentConway,
    parentMono,
    parentVeb1,
  )
where

import Data.Conway.Conway
import Data.Conway.SignExpansion.Dyadic (FiniteSignExpansion (..))
import qualified Data.Conway.SignExpansion.Dyadic as SED
import Data.Conway.Typeclasses

-- | The parent range of a surreal number is one of:
--
-- 1. Empty
--
-- 2. Point (successor sequence)
--
-- 3. Limit sequence
--
-- The type @Maybe@ is used because its monadic nature is used to propagate the emptyness.
type ParentSeq a = Maybe (Either (Conway a) (ConwaySeq a))

type ParentSeq0 a = Maybe (Either (Conway a) (MonoSeq a))

psEmpty :: ParentSeq a
psPoint :: Conway a -> ParentSeq a
psLim :: ConwaySeq a -> ParentSeq a
psEmpty = Nothing

psPoint = Just . Left

psLim = Just . Right

-- | A limit sequence of a @Conway a@.
--
-- * True: @prefix + (veb1 o p c)'@ (or @''@)
--
-- * False: @prefix - (veb1 o p c)'@ (or @''@)
--
-- where @c@ is positive.
data ConwaySeq a = ConwaySeq {csBase :: Conway a, csSign :: Bool, csTerm :: MonoSeq a}

-- | The limit sequence generated by @veb o p c@.
data MonoSeq a
  = -- | @veb1 o p'@ where @p'@ is a limit sequence
    Mono1Seq (Veb1Seq a)
  | -- | A multiples of a @veb1@ sequence.
    --
    -- * True: @veb o p n = {0, veb o p 1, veb o p 2, veb o p 3, ...}@
    --
    -- * False: @veb o p (1 `shr` n) = {veb o p 1, veb o p (1/2), veb o p (1/4),  ...}@
    MonoMultSeq (VebMono a) Bool

-- | The limit sequence generated by @veb1 o p@.
data Veb1Seq a
  = -- | @veb o p'@ or @''@
    Veb1ArgSeq Ordinal (ConwaySeq a)
  | -- | @veb1 o' p@ or @''@
    Veb1OrderSeq (ConwaySeq Natural) (Conway a)
  | -- | The fixed-point iteration sequence.
    --
    -- * True: @(veb1 o p)' = iterate (veb1 o) (p + 1) = {p + 1, veb1 o (p + 1), veb 1 o (veb1 o (p + 1)) , ...}@
    --
    -- * False: @(veb1 o p)' = iterate (veb1 o) (p - 1) = {p - 1, veb1 o (p - 1), veb 1 o (veb1 o (p - 1)) , ...}@
    Veb1IterSeq Ordinal (Conway a) Bool

instance (OrdRing a, One a, Show a) => Show (ConwaySeq a) where
  show ConwaySeq {csBase = b, csSign = s, csTerm = t}
    | isZero b = if s then seqTail else "-" ++ seqTail
    | otherwise = show b ++ " " ++ op ++ " " ++ seqTail
    where
      op = if s then "+" else "-"
      seqTail = show t

instance (OrdRing a, One a, Show a) => Show (MonoSeq a) where
  show (Mono1Seq sa) = show sa
  show (MonoMultSeq (VebMono o p) s) =
    case (o, show p) of
      (0, "0") -> seqCoeff
      (0, "1") -> "w * " ++ seqCoeff
      (0, p') -> "w^[" ++ p' ++ "] * " ++ seqCoeff
      (o', p') -> "φ[" ++ show o' ++ "," ++ p' ++ "] * " ++ seqCoeff
    where
      seqTrue = "{0, 1, 2, 3, ...}"
      seqFalse = "{1, 1/2, 1/4, 1/8, ...}"
      seqCoeff = if s then seqTrue else seqFalse

instance (OrdRing a, One a, Show a) => Show (Veb1Seq a) where
  show (Veb1ArgSeq 0 s) = "w^[" ++ show s ++ "]"
  show (Veb1ArgSeq o s) = "φ[" ++ show o ++ ", " ++ show s ++ "]"
  show (Veb1OrderSeq o s) = "φ[" ++ show o ++ ", " ++ show s ++ "]"
  show (Veb1IterSeq o t s) = "Iter[" ++ funcPart ++ ", " ++ (if s then show (t `add` one) else show (t `sub` one)) ++ "]"
    where
      funcPart = if isZero o then "w^[-]" else "φ[" ++ show o ++ ", -]"

negateParentSeq :: (OrdZero a, One a) => ParentSeq a -> ParentSeq a
negateParentSeq Nothing = Nothing
negateParentSeq (Just (Left x)) = Just $ Left $ neg x
negateParentSeq (Just (Right x)) = Just $ Right $ negateConwaySeq x

negateConwaySeq :: (OrdZero a, One a) => ConwaySeq a -> ConwaySeq a
negateConwaySeq ConwaySeq {csBase = b, csSign = s, csTerm = t} = ConwaySeq {csBase = neg b, csSign = not s, csTerm = t}

type Direction = Bool

parentDyadic :: (FiniteSignExpansion a) => Direction -> a -> Maybe a
parentDyadic isLeft x = SED.parent isLeft (finiteSE x) >>= parseFiniteSE

data LeftRight a = LR (ParentSeq a) (ParentSeq a)

instance (OrdRing a, One a, Show a) => Show (LeftRight a) where
  show (LR ls rs) = "{ " ++ ls' ++ " | " ++ rs' ++ " }"
    where
      ls' = maybe "" show' ls
      rs' = maybe "" show' rs
      show' = either show show

lrConway :: (OrdRing a, FiniteSignExpansion a) => Conway a -> LeftRight a
lrConway x = LR (parentConway True x) (parentConway False x)

parentConway :: (OrdRing a, FiniteSignExpansion a) => Direction -> Conway a -> ParentSeq a
parentConway isLeft x =
  do
    (base, (p, c)) <- trailingView x
    let res = parentMono isLeft (p, c)
    case res of
      Nothing -> parentConway isLeft base
      Just (Left s) -> psPoint $ base `add` s
      Just (Right l) -> psLim $ addSeq base l

parentMono :: (OrdRing a, FiniteSignExpansion a) => Direction -> (VebMono a, a) -> ParentSeq a
parentMono isLeft (p, c)
  | isZero c = psEmpty
  | isNegative c = negateParentSeq $ parentMono (not isLeft) (p, neg c)
  | isOne c = do
      p' <- parentVeb1 isLeft p
      case p' of
        Left p'Succ -> psPoint p'Succ
        Right p'Lim -> psLim $ ConwaySeq {csBase = zero, csSign = True, csTerm = p'Lim}
  | otherwise = do
      -- L: V(o, p).c = { V(o, p).c' + V(o, p)'.n | ... }
      -- R: V(o, p).c = { ... | V(o, p).c'' - V(o, p)'.n }
      c' <- parentDyadic isLeft c
      -- let op = if isLeft then add else sub
      let base = fromVebMono (p, c')
      let cs0 = ConwaySeq {csBase = base, csSign = isLeft, csTerm = undefined}
      let p0'Lower = parentVeb1 True p
      case p0'Lower of
        Nothing -> if isLeft then psPoint base else Nothing
        Just (Left p'Succ) -> psPoint $ base `add` p'Succ
        Just (Right p'Lim) -> psLim $ cs0 {csTerm = p'Lim}

parentVeb1 :: (OrdRing a, FiniteSignExpansion a) => Direction -> VebMono a -> ParentSeq0 a
parentVeb1 isLeft (VebMono (isZero -> True) p) =
  case parentConway isLeft p of
    Nothing -> if isLeft then Just $ Left zero else Nothing
    -- L: V(0, p) = w^{|...} = { 0 | ... } (handled by caller)
    -- R: V(0, p) = w^{...|} = { ... | }
    -- L: V(0, p) = w^{p'|...} = { w^p . n | ... }
    -- R: V(0, p) = w^{...|p''} = { ... | w^p'' . (1 `shr` n)}
    Just (Left p'Succ) -> Just $ Right $ MonoMultSeq (VebMono zero p'Succ) isLeft
    -- L: V(0, p) = w^{p'[n]|...} = { w^p'[n] | ... }
    -- R: V(0, p) = w^{...|p''[n]} = { ... | w^p''[n] }
    Just (Right p'Lim) -> Just $ Right $ Mono1Seq $ Veb1ArgSeq zero p'Lim
parentVeb1 isLeft (VebMono o (isZero -> True))
  | isLeft = do
      co <- parentConway True o
      case co of
        -- Veb1LSuccZero
        Left o'Succ -> Just $ Right $ Mono1Seq $ Veb1IterSeq o'Succ zero isLeft
        -- Veb1LLimitZero
        Right o'Lim -> Just $ Right $ Mono1Seq $ Veb1OrderSeq o'Lim zero
  -- Veb1RSuccZero, Veb1RLimitZero
  | otherwise = Nothing
parentVeb1 isLeft (VebMono o p) = do
  let cp = parentConway isLeft p
  case cp of
    Nothing -> if isLeft then parentVeb1 True (VebMono o zero) else Nothing
    Just (Left p'Succ) -> do
      co <- parentConway True o
      case co of
        -- Veb1LSuccSucc, Veb1RSuccSucc
        Left o'Succ -> Just $ Right $ Mono1Seq $ Veb1IterSeq o'Succ (veb1 o p'Succ) isLeft
        -- Veb1LLimitSucc, Veb1LRimitSucc
        Right o'Lim ->
          let off = getIterOffset isLeft
           in Just $ Right $ Mono1Seq $ Veb1OrderSeq o'Lim (off $ veb1 o p'Succ)
    Just (Right p'Lim) -> Just $ Right $ Mono1Seq $ Veb1ArgSeq o p'Lim

getIterOffset :: (AddSub a, One a) => Bool -> a -> a
getIterOffset isLeft = if isLeft then (`add` one) else (`sub` one)

addSeq :: (OrdRing a) => Conway a -> ConwaySeq a -> ConwaySeq a
addSeq base0 c@ConwaySeq {csBase = b0} = c {csBase = base0 `add` b0}
