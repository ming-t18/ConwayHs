module Data.Conway.Simplicity.Types
  ( ParentSeq,
    ParentSeq0,
    ConwaySeq (..),
    MonoSeq (..),
    Veb1Seq (..),
    LeftRight (..),
    psEmpty,
    psPoint,
    psLim,
  )
where

import Data.Conway.Conway
import Data.Conway.Typeclasses

-- | The parent range of a surreal number is one of:
--
-- 1. Empty
--
-- 2. Point (successor sequence)
--
-- 3. Limit sequence
--
-- The type @Maybe@ is used because its monadic nature is used to propagate the emptyness.
type ParentSeq a = Maybe (Either (Conway a) (ConwaySeq a))

type ParentSeq0 a = Maybe (Either (Conway a) (MonoSeq a))

psEmpty :: ParentSeq a
psPoint :: Conway a -> ParentSeq a
psLim :: ConwaySeq a -> ParentSeq a
psEmpty = Nothing

psPoint = Just . Left

psLim = Just . Right

-- | A limit sequence of a @Conway a@.
--
-- * True: @prefix + (veb1 o p c)'@ (or @''@)
--
-- * False: @prefix - (veb1 o p c)'@ (or @''@)
--
-- where @c@ is positive.
data ConwaySeq a = ConwaySeq {csBase :: Conway a, csSign :: Bool, csTerm :: MonoSeq a}

-- | The limit sequence generated by @veb o p c@.
data MonoSeq a
  = -- | @veb1 o p'@ where @p'@ is a limit sequence
    Mono1Seq (Veb1Seq a)
  | -- | A multiples of a @veb1@ sequence.
    --
    -- * True: @veb o p n = {0, veb o p 1, veb o p 2, veb o p 3, ...}@
    --
    -- * False: @veb o p (1 `shr` n) = {veb o p 1, veb o p (1/2), veb o p (1/4),  ...}@
    MonoMultSeq (VebMono a) Bool

-- | The limit sequence generated by @veb1 o p@.
data Veb1Seq a
  = -- | @veb o p'@ or @''@
    Veb1ArgSeq Ordinal (ConwaySeq a)
  | -- | @veb1 o' p@ or @''@
    Veb1OrderSeq (ConwaySeq Natural) (Conway a)
  | -- | The fixed-point iteration sequence.
    --
    -- * True: @(veb1 o p)' = iterate (veb1 o) (p + 1) = {p + 1, veb1 o (p + 1), veb 1 o (veb1 o (p + 1)) , ...}@
    --
    -- * False: @(veb1 o p)' = iterate (veb1 o) (p - 1) = {p - 1, veb1 o (p - 1), veb 1 o (veb1 o (p - 1)) , ...}@
    Veb1IterSeq Ordinal (Conway a) Bool

data LeftRight a = LR (ParentSeq a) (ParentSeq a)

instance (OrdRing a, One a, Show a) => Show (ConwaySeq a) where
  show ConwaySeq {csBase = b, csSign = s, csTerm = t}
    | isZero b = if s then seqTail else "-" ++ seqTail
    | otherwise = show b ++ " " ++ op ++ " " ++ seqTail
    where
      op = if s then "+" else "-"
      seqTail = show t

instance (OrdRing a, One a, Show a) => Show (MonoSeq a) where
  show (Mono1Seq sa) = show sa
  show (MonoMultSeq (VebMono o p) s) =
    case (o, show p) of
      (0, "0") -> seqCoeff
      (0, "1") -> "w * " ++ seqCoeff
      (0, p') -> "w^[" ++ p' ++ "] * " ++ seqCoeff
      (o', p') -> "φ[" ++ show o' ++ "," ++ p' ++ "] * " ++ seqCoeff
    where
      seqTrue = "{0, 1, 2, 3, ...}"
      seqFalse = "{1, 1/2, 1/4, 1/8, ...}"
      seqCoeff = if s then seqTrue else seqFalse

instance (OrdRing a, One a, Show a) => Show (Veb1Seq a) where
  show (Veb1ArgSeq 0 s) = "w^[" ++ show s ++ "]"
  show (Veb1ArgSeq o s) = "φ[" ++ show o ++ ", " ++ show s ++ "]"
  show (Veb1OrderSeq o s) = "φ[" ++ show o ++ ", " ++ show s ++ "]"
  show (Veb1IterSeq o t s) = "Iter[" ++ funcPart ++ ", " ++ (if s then show (t `add` one) else show (t `sub` one)) ++ "]"
    where
      funcPart = if isZero o then "w^[-]" else "φ[" ++ show o ++ ", -]"

instance (OrdRing a, One a, Show a) => Show (LeftRight a) where
  show (LR ls rs) = "{ " ++ ls' ++ " | " ++ rs' ++ " }"
    where
      ls' = maybe "" show' ls
      rs' = maybe "" show' rs
      show' = either show show
