module Data.Conway.Simplicity.Types
  ( RangeElem (..),
    RangeElemMono (..),
    ParentSeq,
    ParentSeq0,
    ConwaySeq (..),
    MonoSeq (..),
    FixBase,
    Veb1Seq (..),
    LeftRight (..),
    fromFixBase,

    -- * @LeftRight@
    toPair,
    lrLeft,
    lrRight,

    -- * PS builders
    psEmpty,
    psPoint,
    psLim,
    ps0Empty,
    ps0Point,
    ps0Lim,

    -- * Decomposers
    rangeElem,
    rangeElem0,
  )
where

import Data.Conway.Conway
import Data.Conway.Typeclasses

data RangeElem a = EPoint (Conway a) | ELimit (ConwaySeq a)
  deriving (Show)

data RangeElemMono a = MPoint (VebMono a, a) | MLimit (MonoSeq a)
  deriving (Show)

-- | The parent range of a surreal number is one of:
--
-- 1. Empty
--
-- 2. Point (successor sequence)
--
-- 3. Limit sequence
--
-- The type @Maybe@ is used because its monadic nature is used to propagate the emptyness.
type ParentSeq a = Maybe (RangeElem a)

type ParentSeq0 a = Maybe (RangeElemMono a)

psEmpty :: ParentSeq a
psPoint :: Conway a -> ParentSeq a
psLim :: ConwaySeq a -> ParentSeq a
psEmpty = Nothing

psPoint = Just . EPoint

psLim = Just . ELimit

ps0Empty :: ParentSeq0 a
ps0Point :: (VebMono a, a) -> ParentSeq0 a
ps0Lim :: MonoSeq a -> ParentSeq0 a
ps0Empty = Nothing

ps0Point = Just . MPoint

ps0Lim = Just . MLimit

rangeElem :: (Conway a -> b) -> (ConwaySeq a -> b) -> RangeElem a -> b
rangeElem p _ (EPoint x) = p x
rangeElem _ s (ELimit x) = s x

rangeElem0 :: ((VebMono a, a) -> b) -> (MonoSeq a -> b) -> RangeElemMono a -> b
rangeElem0 p _ (MPoint x) = p x
rangeElem0 _ s (MLimit x) = s x

-- | A limit sequence of a @Conway a@.
--
-- * True: @prefix + (veb1 o p c)'@ (or @''@)
--
-- * False: @prefix - (veb1 o p c)'@ (or @''@)
--
-- where @c@ is positive.
data ConwaySeq a = ConwaySeq {csBase :: Conway a, csSign :: Bool, csTerm :: MonoSeq a}

-- | The limit sequence generated by @veb o p c@.
data MonoSeq a
  = -- | @veb1 o p'@ where @p'@ is a limit sequence
    Mono1Seq (Veb1Seq a)
  | -- | A multiples of a @veb1@ sequence.
    --
    -- * True: @veb o p n = {0, veb o p 1, veb o p 2, veb o p 3, ...}@
    --
    -- * False: @veb o p (1 `shr` n) = {veb o p 1, veb o p (1/2), veb o p (1/4),  ...}@
    MonoMultSeq (VebMono a) Bool

-- | The base of a fixed point iteration. It is one of:
--
--  * @0@: @Nothing@
--
--  * @veb1 o p + 1@ or @(veb1 o p) - 1@ where @+@ is @True@ and @-@ is @False@
type FixBase a = Maybe (VebMono a, Bool)

-- | The limit sequence generated by @veb1 o p@.
data Veb1Seq a
  = -- | @veb o p'@ or @''@
    Veb1ArgSeq Ordinal (ConwaySeq a)
  | -- | @veb1 o' p + 1@ or @ - 1@ or @''@
    Veb1OrderSeq (ConwaySeq Natural) (FixBase a)
  | -- | The fixed-point iteration sequence.
    Veb1IterSeq Ordinal (FixBase a)

data LeftRight a = LR (ParentSeq a) (ParentSeq a)

toPair :: LeftRight a -> (ParentSeq a, ParentSeq a)
toPair (LR a b) = (a, b)

lrLeft, lrRight :: LeftRight a -> ParentSeq a
lrLeft (LR a _) = a
lrRight (LR _ b) = b

instance (OrdRing a, One a, Show a) => Show (ConwaySeq a) where
  show ConwaySeq {csBase = b, csSign = s, csTerm = t}
    | isZero b = if s then seqTail else "-" ++ seqTail
    | otherwise = show b ++ " " ++ op ++ " " ++ seqTail
    where
      op = if s then "+" else "-"
      seqTail = show t

instance (OrdRing a, One a, Show a) => Show (MonoSeq a) where
  show (Mono1Seq sa) = show sa
  show (MonoMultSeq (VebMono o p) s) =
    case (o, show p) of
      (0, "0") -> seqCoeff
      (0, "1") -> "w * " ++ seqCoeff
      (0, p') -> "w^[" ++ p' ++ "] * " ++ seqCoeff
      (o', p') -> "φ[" ++ show o' ++ "," ++ p' ++ "] * " ++ seqCoeff
    where
      seqTrue = "{0, 1, 2, 3, ...}"
      seqFalse = "{1, 1/2, 1/4, 1/8, ...}"
      seqCoeff = if s then seqTrue else seqFalse

showFixBase :: (OrdZero a, One a, Show a) => FixBase a -> String
showFixBase Nothing = "0"
showFixBase (Just (x, True)) = "(" ++ show x ++ ") + 1"
showFixBase (Just (x, False)) = "(" ++ show x ++ ") - 1"

instance (OrdRing a, One a, Show a) => Show (Veb1Seq a) where
  show (Veb1ArgSeq 0 s) = "w^[" ++ show s ++ "]"
  show (Veb1ArgSeq o s) = "φ[" ++ show o ++ ", " ++ show s ++ "]"
  show (Veb1OrderSeq o Nothing) = "φ[" ++ show o ++ ", 0]"
  show (Veb1OrderSeq o (Just (v, s))) = "φ[" ++ show o ++ ", (" ++ show v ++ ") " ++ (if s then "+ 1" else "- 1") ++ "]"
  show (Veb1IterSeq o base) = "Iter[" ++ funcPart ++ ", " ++ showFixBase base ++ "]"
    where
      funcPart = if isZero o then "w^[-]" else "φ[" ++ show o ++ ", -]"

instance (OrdRing a, One a, Show a) => Show (LeftRight a) where
  show (LR ls rs) = "{ " ++ ls' ++ " | " ++ rs' ++ " }"
    where
      ls' = maybe "" show' ls
      rs' = maybe "" show' rs
      show' re = case re of
        EPoint p -> show p
        ELimit l -> show l

fromFixBase :: (OrdRing a) => FixBase a -> Conway a
fromFixBase Nothing = zero
fromFixBase (Just (p0, True)) = fromVebMono1 p0 `add` one
fromFixBase (Just (p0, False)) = fromVebMono1 p0 `sub` one
