module Data.Conway.Simplicity.Types
  ( ParentSeq,
    ParentSeq0,
    ConwaySeq (..),
    MonoSeq (..),
    FixBase,
    Veb1Seq (..),
    LeftRight (..),
    psEmpty,
    psPoint,
    psLim,
    fromFixBase,
  )
where

import Data.Conway.Conway
import Data.Conway.Typeclasses

-- | The parent range of a surreal number is one of:
--
-- 1. Empty
--
-- 2. Point (successor sequence)
--
-- 3. Limit sequence
--
-- The type @Maybe@ is used because its monadic nature is used to propagate the emptyness.
type ParentSeq a = Maybe (Either (Conway a) (ConwaySeq a))

type ParentSeq0 a = Maybe (Either (Conway a) (MonoSeq a))

psEmpty :: ParentSeq a
psPoint :: Conway a -> ParentSeq a
psLim :: ConwaySeq a -> ParentSeq a
psEmpty = Nothing

psPoint = Just . Left

psLim = Just . Right

-- | A limit sequence of a @Conway a@.
--
-- * True: @prefix + (veb1 o p c)'@ (or @''@)
--
-- * False: @prefix - (veb1 o p c)'@ (or @''@)
--
-- where @c@ is positive.
data ConwaySeq a = ConwaySeq {csBase :: Conway a, csSign :: Bool, csTerm :: MonoSeq a}

-- | The limit sequence generated by @veb o p c@.
data MonoSeq a
  = -- | @veb1 o p'@ where @p'@ is a limit sequence
    Mono1Seq (Veb1Seq a)
  | -- | A multiples of a @veb1@ sequence.
    --
    -- * True: @veb o p n = {0, veb o p 1, veb o p 2, veb o p 3, ...}@
    --
    -- * False: @veb o p (1 `shr` n) = {veb o p 1, veb o p (1/2), veb o p (1/4),  ...}@
    MonoMultSeq (VebMono a) Bool

-- | The base of a fixed point iteration. It is one of:
--
--  * @0@: @Nothing@
--
--  * @veb1 o p + 1@ or @(veb1 o p) - 1@ where @+@ is @True@ and @-@ is @False@
type FixBase a = Maybe (VebMono a, Bool)

-- | The limit sequence generated by @veb1 o p@.
data Veb1Seq a
  = -- | @veb o p'@ or @''@
    Veb1ArgSeq Ordinal (ConwaySeq a)
  | -- | @veb1 o' p + 1@ or @ - 1@ or @''@
    Veb1OrderSeq (ConwaySeq Natural) (FixBase a)
  | -- | The fixed-point iteration sequence.
    Veb1IterSeq Ordinal (FixBase a)

data LeftRight a = LR (ParentSeq a) (ParentSeq a)

instance (OrdRing a, One a, Show a) => Show (ConwaySeq a) where
  show ConwaySeq {csBase = b, csSign = s, csTerm = t}
    | isZero b = if s then seqTail else "-" ++ seqTail
    | otherwise = show b ++ " " ++ op ++ " " ++ seqTail
    where
      op = if s then "+" else "-"
      seqTail = show t

instance (OrdRing a, One a, Show a) => Show (MonoSeq a) where
  show (Mono1Seq sa) = show sa
  show (MonoMultSeq (VebMono o p) s) =
    case (o, show p) of
      (0, "0") -> seqCoeff
      (0, "1") -> "w * " ++ seqCoeff
      (0, p') -> "w^[" ++ p' ++ "] * " ++ seqCoeff
      (o', p') -> "φ[" ++ show o' ++ "," ++ p' ++ "] * " ++ seqCoeff
    where
      seqTrue = "{0, 1, 2, 3, ...}"
      seqFalse = "{1, 1/2, 1/4, 1/8, ...}"
      seqCoeff = if s then seqTrue else seqFalse

showFixBase :: (OrdZero a, One a, Show a) => FixBase a -> String
showFixBase Nothing = "0"
showFixBase (Just (x, True)) = "(" ++ show x ++ ") + 1"
showFixBase (Just (x, False)) = "(" ++ show x ++ ") - 1"

instance (OrdRing a, One a, Show a) => Show (Veb1Seq a) where
  show (Veb1ArgSeq 0 s) = "w^[" ++ show s ++ "]"
  show (Veb1ArgSeq o s) = "φ[" ++ show o ++ ", " ++ show s ++ "]"
  show (Veb1OrderSeq o Nothing) = "φ[" ++ show o ++ ", 0]"
  show (Veb1OrderSeq o (Just (v, s))) = "φ[" ++ show o ++ ", (" ++ show v ++ ") " ++ (if s then "+ 1" else "- 1") ++ "]"
  show (Veb1IterSeq o base) = "Iter[" ++ funcPart ++ ", " ++ showFixBase base ++ "]"
    where
      funcPart = if isZero o then "w^[-]" else "φ[" ++ show o ++ ", -]"

instance (OrdRing a, One a, Show a) => Show (LeftRight a) where
  show (LR ls rs) = "{ " ++ ls' ++ " | " ++ rs' ++ " }"
    where
      ls' = maybe "" show' ls
      rs' = maybe "" show' rs
      show' = either show show

fromFixBase :: (OrdRing a) => FixBase a -> Conway a
fromFixBase Nothing = zero
fromFixBase (Just (p0, True)) = fromVebMono1 p0 `add` one
fromFixBase (Just (p0, False)) = fromVebMono1 p0 `sub` one
